<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DSP_RMI]]></title>
    <url>%2F2019%2F05%2F16%2FDSP-RMI%2F</url>
    <content type="text"><![CDATA[RMI例子 远程接口 IHello.java 1234567// define remote interfaceimport java.rmi.Remote;import java.rmi.RemoteException;public interface IHello extends Remote &#123; public int helloWorld()throws RemoteException;&#125; 实现类 Hello.java 123456789101112131415161718// define the implementation classimport java.io.Serializable;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class Hello extends UnicastRemoteObject implements IHello&#123; private static final long serialVersionUID = 1L; private int index = 0; protected Hello() throws RemoteException&#123; &#125; @Override public int helloWorld() &#123; System.out.println("Hello!"); return ++index; &#125;&#125; 服务器端 HelloServer.java12345678910111213141516import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class HelloServer &#123; public static void main(String args[]) &#123; try &#123; IHello rhello = new Hello(); System.setProperty("java.security.policy","file:./mypolicy"); Registry registry = LocateRegistry.createRegistry(8888); registry.bind("test",rhello); // in client side rmi://localhost:8888/test System.out.println("Remote Hello Object is bound succesfully!"); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端 HelloClient.java 123456789101112131415import java.rmi.Naming;public class HelloClient &#123; public static void main(String args[]) &#123; try &#123; for(int i=0;i&lt;5;i++) &#123; IHello rhello = (IHello) Naming.lookup("rmi://192.168.31.102:8888/test"); System.out.println(rhello.helloWorld()); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Equicalence Partitioning Class]]></title>
    <url>%2F2019%2F05%2F02%2FEC%2F</url>
    <content type="text"><![CDATA[在软件工程中，常常遇到测试数据不完全而不能有效地测试出bug的过程，这个时候需要对所有输出进行划分，同时在边界需要格外注意，多测试几组边界值。 empty digits characters 六位id的可写成 id = {num|num = (\d){6,6}}]]></content>
  </entry>
  <entry>
    <title><![CDATA[ds5]]></title>
    <url>%2F2019%2F04%2F26%2Fds5%2F</url>
    <content type="text"><![CDATA[4-26笔记 7 fat client microsoft excel thin client automatioc flight check-in machine 18which is on client and which on server 27localhost：在计算机网络中，localhost（意为“本地主机”，指“这台计算机”）是给回路网络接口（loopback）的一个标准主机名，相对应的IP地址为127.0.0.1（IPv4）和[::1]（IPv6）。127.0.0.1是回送地址，指本地机。127.0.0.1是用来检测网络的自己的IP.就是说任何一台电脑来说,不管是否连接到INTERNET上,127.0.0.1对于自己来说都是自己.就是说,每台电脑都是由4位的256进制数组成的.而192.168.1.102现在是本机，但本机也可以设置成其他ip地址，但127.0.0.1一定是指本机。 JAVA client-server 简单例子Socketclient.java123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class SocketClient &#123; public static void main(String args[]) throws UnknownHostException, IOException &#123; Scanner sc = new Scanner(System.in); Socket socket = new Socket("127.0.0.1", 54321); // get input stream BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); // get output stream PrintStream ps = new PrintStream(socket.getOutputStream()); // write string into server ps.println(sc.nextLine()); // print the reversed string from server System.out.println(br.readLine()); socket.close(); &#125;&#125;- SocketServer.java1234567891011121314151617181920212223242526272829303132333435import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class SocketServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(54321); System.out.println("Server is on, binded to 54321 port"); while (true) &#123; final Socket socket = server.accept(); new Thread() &#123; public void run() &#123; try &#123; // get the input stream BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); String line = br.readLine(); line = new StringBuilder(line).reverse().toString(); ps.println(line); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRE词组]]></title>
    <url>%2F2019%2F04%2F24%2FGRE%E8%AF%8D%E7%BB%84%2F</url>
    <content type="text"><![CDATA[GRE 常用词组 Day 1 stop short of jockey for per se silver lining Historian George Coulton attributed a silver lining to the Black Death: prosperity engendered by diminished competition for food, shelter, and work led survivors of the epidemic into the Renaissance and subsequent rise of modern Europe. in the grip of Our “frailities”-emotions and motives such as rage, fear, greed, gluttony, joy, lust, love-may be a very mixed assortment, but they share at least one immediate quality: we are, as we say, “in the grip of” them. bear out The effects of the mechanization of women’s work have not borne out the frequently held assumption that new technology is inherently revolutionary. status quo hinge on According to this model, specialist foundings hinge on the interplay between legitimation and competitive forces, both of which are functions of the density(total number) of firms in a particular specialist population. be pitted against be punctuated by The semi-final was punctuated by a series of malicious fouls. run for run against depart from set apart prior to have a bearing on More generally, however, whether or not a composition establishes a new principle in the history of music has little bearing on its aesthetic worth. take sides stem from in the light of In light of this economic depression, a mass layoff is about to happen. compensate for To compensate for the substantial decline in the availability of fossil fuels in future years, we will have to provide at least an equivalent alternative energy source. Day 2 gloss over Great comic artists assume that truth may bear all lights, and thus they seek to accentuate contradictions in social action, not gloss over or transcend them by appeals to extra social symbols of divine ends, cosmic purpose, or laws of nature. shed/throw/cast light on sign into Sponsors of the bill were relieved because there was no opposition to it within the legislature (立法机关) until after the measure had been signed into law. gain favor 获得青睐 ensue from rebel against press for They had begun to press for changes in census-taking methods as part of their participation in the antislavery movment. hold in check be rooted in die hard a salvo of 大量的 drop out drop a college or a race explain away 通过解释消除 subject to Digital data are not subject to the vagaries of difficult-to-control chemical processing. get along with at stake leave out 忽略 a quantity of 一些examples deduce from (axiom公理) at large 整个的 Admittedly, morality must be concerned with what is honored by the commuity at large.]]></content>
      <tags>
        <tag>GRE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补天]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%A1%A5%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[JAVA 入门到放弃 Access modifiers(specifiers) in java protected 基类的 protected 成员是包内可见的，并且对子类可见； 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。 detail overloadeach overloaded method must take a unique list of the argument types override（1）重写方法必须和被重写方法具有相同的参数列表（包括顺序及个数还有类型），返回类型必须和被重写方法的返回类型相同或者是返回类型的子类型。 （2）重写方法的访问控制修饰符不能比被重写方法更严格（比如一个在父类中声明为public的方法重写成一个protected的方法）。 （3）只有实例方法才能被重写，超类中的static和final方法不能被重写。 （4）重写方法不能抛出新的检查异常，或者是抛出比被重写方法声明的检查异常更广泛的检查异常。 （5）注意一种特殊情况：如果超类的方法版本中声明了检查异常，但重写的子类方法中没有声明，这时如果使用多态的方式进行调用，那么编译器认为你调用的是声明了异常的方法。 （6）尽管多态是在编译时确定对象的类型，但在编译时，还是根据父类的方法声明进行程序检查。因此，如果子类中定义的方法，在父类中没有定义，则会出项编译错误。 upcastthe act of converting a subclass reference into a baseclass reference 缺点：使用向上转型时不能调用子类特有的方法了 优点：一个父类有多个子类时，一个子类重写了许多父类的方法，可以声明一个public static函数统一对每个属于父类的子类进行操作，节省代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author Spycsh * 2019-04-28 */class Car &#123; private String carDescription = "Car"; public void run() &#123; System.out.println("父类run方法"); &#125; public void speed() &#123; System.out.println("父类speed方法"); &#125; public String getDescription() &#123;return carDescription;&#125;;&#125;class Benz extends Car&#123; public void run() &#123; System.out.println("Benz:run方法"); &#125; public void speed() &#123; System.out.println("Benz:speed方法"); &#125; &#125;class BMW extends Car&#123; public void run() &#123; System.out.println("BMW:run方法"); &#125; public void speed() &#123; System.out.println("BMW:speed方法"); &#125;&#125;class Porsche extends Car&#123; private String carDescription = "Porsche is the best!"; public void run() &#123; System.out.println("Porche:run方法"); &#125; public void speed() &#123; System.out.println("Porche:speed方法"); &#125; public void price() &#123; System.out.println("Porche:price方法"); &#125; public String getDescription() &#123;return carDescription;&#125;;&#125;public class UpcastEX extends Car&#123; /** * @param car * !upcast * without upcast you need to define show method for each car brand * save code amount */ public static void show(Car car) &#123; car.run(); car.speed(); &#125; public static void showAll(Car[] e) &#123; for(Car i:e) &#123; show(i); &#125; &#125; public static void main(String[] args) &#123; Car[] carFleet = &#123; new Benz(), new BMW(), new Porsche() &#125;; showAll(carFleet); Car porsche911 = new Porsche(); //porsche911.price(); // ERROR // !cannot be implemented because of upcasting! // baseclass don`t define price()! System.out.println("test getDescription:"); // show that although upcasting, field are accessed // in subclass, not baseclass. System.out.println(porsche911.getDescription()); &#125;&#125; OUTPUT Benz:run方法 Benz:speed方法 BMW:run方法 BMW:speed方法 Porche:run方法 Porche:speed方法 test getDescription: Porsche is the best! staticstatic修饰方法 静态方法 属于类的方法 即访问它不需要实例对象就能访问 finalstatic, final修饰data static 强调只有一份，final 说明是一个常量，final定义的基本类型(primitive)的值是不可改变的，但是fianl定义的引用对象的值是可以改变的 只申明final，每次new产生不同的对象static, final一起使用时，只有一块存储地址申明static final，每次new产生相同对象 final修饰methods 把方法锁定，确保在继承中使用方法行为不变，并且不会被覆盖其二是效率，如果一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。 转为内嵌调用的目的是节省开销，因为编译器发现一个final方法调用命令时，会跳过程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来替代方法调用。但是如果一个方法很大，程序很膨胀，就会看不到内嵌带来的任何性能的提高。 final修饰类 当某个类的整体定义为final时，表明该类不能被继承，方法不能被覆盖，且final类中的所有方法都隐式指定为是final的，方法声明为final后还可以有效地“关闭”动态绑定。 Containers synchronized 修饰代码块，其他试图访问该对象的线程阻塞123synchronized(this) &#123; // 同步代码块&#125; 对象作为锁123synchronized (account) &#123; // 同步代码块&#125; 没有明确的对象作为锁1234567891011121314class Test implements Runnable&#123; private byte[] lock = new byte[0]; // 特殊的instance变量 public void method() &#123; synchronized(lock) &#123; // todo 同步代码块 &#125; &#125; public void run() &#123; &#125;&#125; 参考资料 消费者-生产者例子 lambda事件监听12345678910// 使用匿名内部类 btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; System.out.println("Hello World!"); &#125; &#125;); // 或者使用 lambda expression btn.setOnAction(event -&gt; System.out.println("Hello World!")); 排序，线程，集合用法参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[DSP]]></title>
    <url>%2F2019%2F04%2F13%2FDSP%2F</url>
    <content type="text"><![CDATA[digital signal processing]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ds4]]></title>
    <url>%2F2019%2F04%2F12%2Fds4%2F</url>
    <content type="text"><![CDATA[2019-04-12 笔记 File IO operation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.*;import java.io.*;/** * @author Spycsh ●int countLines(): count line amount of file ●void print(): * print file on command line ●void copy(String filename): copy file * content to the file ‘filename’ ●void delete(): delete the file ●void * printDirectory(): prints the file directory ●List&lt;String&gt; * getOtherFiles(): returns list of other files in same directory as * file Addtionally, create a test class which demonstrates the * functionality of your IOFile class! */public class FileIo &#123; private String fileName; FileIo(String fileName) &#123; this.fileName = fileName; &#125; int countLines() throws FileNotFoundException &#123; int lineNum = 1; File file = new File(this.fileName); FileReader fr = new FileReader(file); char[] a = new char[500]; try &#123; fr.read(a); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; for (char c : a) &#123; if (c == '\n') lineNum += 1; &#125; return lineNum; &#125; void print() throws FileNotFoundException &#123; File file = new File(this.fileName); FileReader fr = new FileReader(file); char[] a = new char[500]; try &#123; fr.read(a); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; for (char c : a) &#123; System.out.print(c); &#125; &#125; void copy(String filename) throws IOException &#123; // create a new destination file with the filename File copyfile = new File(filename); copyfile.createNewFile(); FileWriter fw = new FileWriter(copyfile); // Read the source file File sourcefile = new File(this.fileName); FileReader fr = new FileReader(sourcefile); char[] a = new char[500]; try &#123; fr.read(a); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; for (char c : a) &#123; fw.write(c); &#125; fr.close(); fw.close(); &#125; void delete() &#123; File file = new File(this.fileName); file.delete(); if (file.exists() == true) &#123; System.out.println("delete fail!"); &#125; else &#123; System.out.println("delete success!"); &#125; &#125; void printDirectory() &#123; File file = new File(this.fileName); System.out.println(file.getParent()); &#125; List&lt;String&gt; getOtherFiles() &#123; List&lt;String&gt; anotherFile = new ArrayList&lt;String&gt;(); // first we should get the directory File file = new File(this.fileName); String directoryStr = file.getParent(); File directory = new File(directoryStr); String[] allfile = directory.list(); for (String f : allfile) &#123; // filter given file // We should use equals rather than == // because we just need to filter // by comparing content if (!f.equals(file.getName())) anotherFile.add(f); &#125; return anotherFile; &#125;&#125;]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SWE]]></title>
    <url>%2F2019%2F04%2F11%2FSWE%2F</url>
    <content type="text"><![CDATA[2019-04-09 笔记 14 Social acceptability: base on culture and region SWING123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import javafx.scene.control.Button;import javafx.scene.control.CheckBox;import java.util.*;/** * @author Spycsh * */public class FruitHodgepodge &#123; public static void main(String[] args) &#123; JFrame f = new JFrame(); f.setSize(600, 400); f.setTitle("FruitOrder"); JPanel panel = new JPanel(); Set&lt;String&gt; allFruitList = new HashSet&lt;String&gt;(); // display all fruit choosed f.getContentPane().setLayout(new FlowLayout());// f.add("Nor", new Button("Nor")); LinkedList&lt;String&gt; boxList = new LinkedList&lt;String&gt;(); Collections.addAll(boxList, "apple banana kiwi orange melon grape".split(" ")); JCheckBox[] cbs = new JCheckBox[boxList.size()]; for (int i = 0; i &lt; boxList.size(); i++) &#123; JCheckBox cb = cbs[i] = new JCheckBox(boxList.get(i)); cb.addChangeListener(new ChangeListener() &#123; @Override public void stateChanged(ChangeEvent e) &#123; // get the event source( checkbox itself) JCheckBox checkBox = (JCheckBox) e.getSource(); System.out.println(checkBox.getText() + " 是否选中: " + checkBox.isSelected()); if (checkBox.isSelected()) allFruitList.add(checkBox.getText()); else allFruitList.remove(checkBox.getText()); System.out.println(allFruitList); &#125; &#125;); panel.add(cb); &#125; JButton btn = new JButton(); btn.setText("Display the order!"); btn.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; JOptionPane testOpt = new JOptionPane(); testOpt.showMessageDialog(new JFrame(), "Your oder:" + "\n" + allFruitList); &#125; &#125;); panel.add(btn); f.setContentPane(panel); // f.setVisible(true); &#125;&#125; JAVAFX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package application;/** * @author Spycsh * Main window: user can choose from 6 different fruits * After confirming the choice of fruits another window will pop up and tell the user the choice of fruits */import javafx.application.Application;import javafx.stage.Stage;import javafx.scene.Scene;import javafx.scene.layout.BorderPane;import javafx.scene.Group;import javafx.scene.control.CheckBox;import javafx.beans.value.ChangeListener;import javafx.beans.value.ObservableValue;import javafx.scene.layout.GridPane;import javafx.scene.control.Button;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.text.Text;import java.util.*;import java.util.regex.*;public class FruitHodgepodge extends Application &#123; @Override public void start(Stage primaryStage) &#123; try &#123; BorderPane root = new BorderPane(); GridPane gp = new GridPane(); Scene scene = new Scene(gp, 500, 300); LinkedList&lt;String&gt; boxList = new LinkedList&lt;String&gt;(); Collections.addAll(boxList, "apple banana kiwi orange melon grape".split(" ")); CheckBox[] cbs = new CheckBox[boxList.size()]; LinkedList&lt;String&gt; allFruitList = new LinkedList&lt;String&gt;(); // display all fruit choosed // final CheckBox cb; for (int i = 0; i &lt; boxList.size(); i++) &#123;// cbs[i] = boxList.poll(); CheckBox cb = cbs[i] = new CheckBox(boxList.get(i));// final CheckBox cb0 = new CheckBox("checkBox");// final CheckBox cb1 = new CheckBox("aa"); cb.selectedProperty().addListener(new ChangeListener&lt;Boolean&gt;() &#123; public void changed(ObservableValue&lt;? extends Boolean&gt; ov, Boolean old_val, Boolean new_val) &#123;// System.out.println(cb.isSelected());&#125; if (new_val) &#123; allFruitList.offer(cb.getText()); &#125; else &#123; allFruitList.remove(cb.getText()); &#125; System.out.println(allFruitList); &#125; &#125;); gp.add(cb, 0, i); &#125; Button btn = new Button(); btn.setText("Display the order!"); btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent event) &#123; Group root = new Group(); Scene scene = new Scene(root, 300, 250);// Stage stg = new Stage();// System.out.println((String)allFruitList.toString());// Pattern pattern = Pattern.compile("'(\\D+)'");// String i = (String)allFruitList.toString();// Matcher m = pattern.matcher(i);// if (m.find())&#123;// Text text = new Text(100, 100, m.group(1));// root.getChildren().add(text);// &#125;// String[] arr = allFruitList.toString().split("'"); System.out.println(); String orderString = new String(); for (String s : allFruitList) &#123; orderString += s + "\n"; &#125; Text text = new Text(100, 100, "final order:" + "\n" + orderString); root.getChildren().add(text); primaryStage.setScene(scene); primaryStage.show(); &#125; &#125;); gp.add(btn, 10, 0); // place the button scene.getStylesheets().add(getClass().getResource("application.css").toExternalForm()); primaryStage.setScene(scene); primaryStage.show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; launch(args); &#125;&#125;]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ds3h]]></title>
    <url>%2F2019%2F04%2F09%2Fds3h%2F</url>
    <content type="text"><![CDATA[2019-04-09 笔记 P16 What does a ds do? share hardwares, software and data let computers coordinate and synchronize offer users an integrated computing facility not limited by location P17 What is the essetial part? auto scaling &amp; load balance 城市规划例子,when a computer is broken, it will be slower for the system implementation because of the boundary computation which counts on the coordinations one and another computers, so as for synchronization the system have to wait for the slowest computer, with heavier load than others, to process. P18 (b) filters the redundant info and ensure the useful info procured to minimum. (b) will have a higher speed of response. P26 What is Mobility Transparency? eg. Stream serialize deserialize]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eigen-everthing]]></title>
    <url>%2F2019%2F04%2F08%2Feigen-everthing%2F</url>
    <content type="text"><![CDATA[brief introduction of eigenvalue and eigenvector in linear algebra determinant 行列式 eigenvalue特征值/eigenvector特征向量/eigenspace特征空间(all of the eigenvectors that correspond the eigrnvalue) null space nontrival]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ds2]]></title>
    <url>%2F2019%2F04%2F05%2Fds2%2F</url>
    <content type="text"><![CDATA[2019-04-05 笔记 make every attribute private and Use getter and setter to access them Communication of DS synchronous: The sender may block activity until acknowledgement from receiver big-endian大端法 small-endian小端法 ASCII, Unicode external data representation and marshalling alternative method Streamsnote transforming in bytes and characters encoded in unicode, must be 2 bytes not 1 class Employee implements Serializable(In China)-&gt; Seralization-&gt;deserialization-&gt;class Employee(In luebeck) 例子说明：建立一个Student类，把它用Stream的方式serialize再deserialize,从而实现信息的传输。 定义Student类1234567891011121314151617import java.io.*;public class Student implements Serializable &#123; private static final long serialVersionUID = 1L; private int studentNumber; private String degreeCourse; Student(int studentNumber, String degreeCourse) &#123; this.studentNumber = studentNumber; this.degreeCourse = degreeCourse; &#125; @Override public String toString() &#123; return "studentNumber:" + studentNumber + " " + "degreeCourse:" + degreeCourse; &#125;&#125; serialize过程12345678910111213141516import java.io.ObjectOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class TestSerializing &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fos = new FileOutputStream("test"); ObjectOutputStream oos = new ObjectOutputStream(fos); Student chen = new Student(12, "ITB"); oos.writeObject(chen); oos.close(); fos.close(); &#125;&#125; deserialize过程12345678910111213141516171819import java.io.*;public class TestDeserialize &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; FileInputStream fos = new FileInputStream("test"); ObjectInputStream oos = new ObjectInputStream(fos); Student aStudent = null; try &#123; aStudent = (Student) oos.readObject(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(aStudent.toString()); oos.close(); fos.close(); &#125;&#125; 结果test文件中显示乱码，是serialize后的字符流deserialize后通过自己定义的toString打印可以输出原来的信息 疑难 test文件建在项目文件夹而不是src文件夹下 使用ObjectInputStream反序列化的时候，ObjeectInputStream会先读取文件中的serialVersionUID，然后与本地的class文件的serialVersionUID进行对比，如果这两个id不一致，反序列则失败 因此在Student class中定义 1private static final long serialVersionUID = 1L; 即可 参考资料Source]]></content>
      <tags>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse 高效代码]]></title>
    <url>%2F2019%2F04%2F04%2FEclipse%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Eclipse use &amp; code convention Eclipse use项目导出压缩包File-&gt;Export-&gt;General-&gt;选择要压缩的类型 修改缩进等格式(CTRL+SHIFT+F)选中代码-&gt;Source-&gt;Format 添加javadoc注释（ALT+SHIFT+J)选中元素-&gt;Source-&gt;Generate Element Comment 改名(ALT+SHIFT+R)选中需要改名的元素-&gt;右键Refactor-&gt;Rename.将会修改文件中所有有这个名字的元素 生成javadoccode conventionjava code convention Javadoc comment Header/Classes Functions Name Package: student Class&amp;Inteface: Student variable&amp;method: inputFileSize constant:MAXWEIGHT Layout/indentation Space]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Information about application for master degree]]></title>
    <url>%2F2019%2F03%2F19%2FMaster%2F</url>
    <content type="text"><![CDATA[德电160硕士申请 德国信息表 大学名 相关专业名称 地点 绩点要求 托福/GRE要求 申请截止日期 评价 亚琛工业大学) Media Infomatics（多媒体信息） 波恩&amp;亚琛 托福90 3.1 EE,IT,CE 托福90 GREverbal超过%15，quantitive超过%75 Dortmund 大学 机器人自动化 Dortmund 80 3.31 机器人研究方面很强 慕尼黑工业大学 ECE 慕尼黑 3.5+ 88 斯图加特大学 infomation technology 官网 DAAD网址 Stuttgart 70%ofbest-on-scale, e.g.70%/100%; 2.8/4; 2.5/1.0 (for German Marks) 托福80 2.15 EU citizens do not pay tuition, whereas non-EU citizens pay a tuition of 1,500 EUR per semester.（有学费要求） Computer Science 官网 DAAD网址 无 托福80 2.15（winter semester） 6.15(summer semester) Bachelor’s degree with a programme duration of at least six semesters in computer science, software engineering, or in a closely related subject(专业匹配度可能较低)EU citizens do not pay tuition, whereas non-EU citizens pay a tuition of 1,500 EUR per semester.（有学费要求） Saarland University萨尔大学 Saarbrücken Graduate School of Computer Science Saarbrücken 75%以上 推荐GRE，托福95/120 11/15；根据专业 不用学费，强在：马普所，视觉信息但毕业很难，挂科率极高 Saarland University萨尔大学DAAD网址 Visual Computing (MSc) Saarland University萨尔大学 Embedded Systems (MSc) Saarland University萨尔大学 Mathematics and Computer Science (MSc) Saarland University萨尔大学 Computer Science (MSc) KIT EEM,FE,MPD,MSEM,POM,ISEM Karlsruhe 托福90 1/15 30000欧 基本简介学校概览 11所精英大学 理工类3所（慕尼黑工业大学、德累斯顿工业大学、亚琛工业大学），文理类8所（海德堡大学、 柏林自由大学、柏林洪堡大学、慕尼黑大学、图宾根大学、康斯坦茨大学、科隆大学、不莱梅大学） 大学名称对应 TU9 九所德国大学，包括亚琛工业大学RWTH Aachen, 柏林工业大学TU Berlin, 不伦瑞克工业大学TU Braunschweig, 达姆施达特工业大学TU Darmstadt, 德累斯顿工业大学TU Dresden, 莱布尼茨-汉诺威大学Leibniz Universität Hannover, 卡尔斯鲁厄理工学院Karlsruher Institut für Technologie, 慕尼黑工业大学TU München, 斯图加特大学Universität Stuttgart。九所大学都是1900年之前成立的理工高校。 TU9联盟主席Ernst Schmachtenberg博士教授指出，”TU9理工高校联盟就是科研实力的代名词。“ U15 U15大学联盟是德国的大型高校、研究型高校联盟，成立于2012年10月12日。联盟成立宗旨为改善德国科研和教育的架构。占德国高校总数13%的十五所高校，承担了37%的第三方资助、60%的医科资助、43%的博士授予，并获得了43%的莱布尼茨奖。目前联盟主席为海德堡大学校长爱特尔(Bernd Eitel)。联盟成员,柏林自由大学,海德堡大学,柏林洪堡大学,波恩大学,法兰克福大学,弗莱堡大学,哥廷根大学,汉堡大学,科隆大学,莱比锡大学,美因茨大学,慕尼黑大学,明斯特大学,图宾根大学,维尔茨堡大学. DAAD查找路径：https://www.daad.de/deutschland/studienangebote/international-programmes/en/result/?crossFac=&amp;cert=&amp;admReq=&amp;scholarshipLC=&amp;scholarshipSC=&amp;degree%5B%5D=&amp;fos=&amp;langDeAvailable=&amp;langEnAvailable=&amp;lang%5B%5D=&amp;cit%5B%5D=&amp;tyi%5B%5D=&amp;ins%5B%5D=&amp;dur%5B%5D=&amp;sort=4&amp;subjects%5B%5D=&amp;q=&amp;limit=10&amp;offset=&amp;display=list]]></content>
  </entry>
  <entry>
    <title><![CDATA[少年的诗]]></title>
    <url>%2F2018%2F12%2F13%2F%E5%B0%91%E5%B9%B4%E7%9A%84%E8%AF%97%2F</url>
    <content type="text"><![CDATA[三峡江声流笔底, 六朝帆影落樽前胸中机杼，笔底波澜写一点诗，总是好的 《侠的诗》 “傲指弹云分入酒，青冠流古照秋霜”太平无侠士那就写一点诗放浪侠气 「侠」辞京飘迹楚山茫，谑眼穿尘淡冕光。傲指弹云分入酒，青冠流古照秋霜。 《少年游》 “花有重开日，人无再少年”最好的时光总是少年时那走遍的江河 「入山」山深纵马伫难前，步下飞光百丈渊。雾卷云廊封道尽，雨开峰骨作桥源。悠笛风远惊人迹，长海际回忆陌年。绝处寻松掬水月，春秋一脉本多缘。 「古原雨」故迹青鸦驻，三江入古原。立堤涛水逝，临野聚峰眠。塔外清魂雨，烟间断梦田。萧霜凋旧木，归马闭门前。 「题赛里木湖」深云压海境，微雨落晶珠。几骑寻闲客，风波自在途。 《韵之心》 古有琴谱阳关三叠“劝君更进一杯酒，西出阳关无故人”古有诗歌驻马衔杯“圣代即今多雨露，暂时分手莫踌躇” 「缘深缘浅，留念诸君」何泣春江归晚照？松风水落对槐花。遗朝柳折留寻念，此坊歌倾续梦茶。解带吹心风作客，流光转忆泪分霞。云终不见诸君影，碧海行帆懒问涯。 「岳麓•祭•忆君之风忆水长」 望尽湘江暮，亭间墨客愁。满林兼叶落，独木与谁谋！老雁飞斜镜，青衫立冷丘。出钩疑钓叟，惟是月如舟。 《家国情》 “王师北定中原日”太平年间曾经的荣辱仿佛被渐渐淡化了而那血脉奔腾的黄河长江却依然肃穆 「记南京大屠杀」 寇兵侵戮昔悲史，瑟瑟汗青警自鸣。国父陵前国尽复，雨花台上雨堪惊！三江拾恨祭英骨，亿气同途筑远程。勿任危心流海去，涯间舟载惜天明。]]></content>
  </entry>
</search>
